name: Deploy to Production

on:
  push:
    branches:
      - main
    paths:
      - 'backend/**'
      - 'frontend/**'
      - '.github/workflows/deploy.yml'
      - 'docker-compose.yml'

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v2

    - name: Deploy to server
      uses: appleboy/ssh-action@master
      with:
        host: ${{ secrets.SERVER_HOST }}
        username: ${{ secrets.SERVER_USER }}
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        script: |
          # Переходим в директорию проекта
          cd /var/www/fonds-relations
          
          # Авторизуемся в Docker Hub с использованием токена
          echo "${{ secrets.DOCKERHUB_TOKEN }}" | docker login -u ${{ secrets.DOCKERHUB_USERNAME }} --password-stdin
          
          # Останавливаем все контейнеры Docker
          docker stop $(docker ps -aq) || true
          
          # Удаляем все остановленные контейнеры
          docker rm $(docker ps -aq) || true
          
          # Удаляем неиспользуемые образы
          docker image prune -af
          
          # Проверяем, что порт 8000 свободен
          if lsof -i:8000; then
            echo "Port 8000 is still in use. Trying to find and kill the process..."
            fuser -k 8000/tcp || true
            sleep 5
          fi
          
          # Проверяем, что порт 3000 свободен для фронтенда
          if lsof -i:3000; then
            echo "Port 3000 is still in use. Trying to find and kill the process..."
            fuser -k 3000/tcp || true
            sleep 5
          fi

          # Обновляем код
          git fetch origin main
          git reset --hard origin/main
          
          cd backend
          
          # Исправляем права доступа для start.sh
          chmod +x start.sh
          echo "Applied executable permissions to start.sh"
          
          # Создаем .env из примера если его нет
          if [ ! -f .env ]; then
            cp .env.example .env
          fi
          
          # Обновляем переменные окружения из секретов
          sed -i "s/your-secret-key-here/${{ secrets.APP_SECRET_KEY }}/g" .env
          sed -i "s/your-email@gmail.com/${{ secrets.SMTP_USER }}/g" .env
          sed -i "s/your-app-specific-password/${{ secrets.SMTP_PASSWORD }}/g" .env
          
          cd ..
          
          # Запускаем контейнеры
          docker-compose down
          docker-compose up -d --build
          
          # Увеличиваем время ожидания до 30 секунд
          echo "Waiting 30 seconds for containers to start..."
          sleep 30
          
          # Проверяем запущенные контейнеры и их состояние
          docker ps -a
          
          # Проверяем логи контейнеров
          docker-compose logs --tail=50
          
          # Проверяем, что бэкенд контейнер запущен
          if ! docker ps | grep -q backend; then
            echo "Backend container is not running!"
            docker-compose logs backend
            exit 1
          fi
          
          # Проверяем, что фронтенд контейнер запущен
          if ! docker ps | grep -q frontend; then
            echo "Frontend container is not running!"
            docker-compose logs frontend
            exit 1
          fi
          
          # Проверяем сетевые соединения внутри Docker
          docker exec $(docker ps | grep backend | awk '{print $1}') netstat -tulpn || echo "Could not check network connections"
          
          # Проверяем, что API отвечает и возвращает правильный статус
          echo "Checking API health..."
          # Проверяем с более подробной информацией
          curl -v http://localhost:8000/docs
          
          # Пробуем подключиться к API
          for i in {1..5}; do
            echo "Attempt $i: Checking API health..."
            response=$(curl -s http://localhost:8000/api/v1)
            if echo "$response" | grep -q '"status":"ok"'; then
              echo "API health check succeeded!"
              break
            fi
            
            if [ $i -eq 5 ]; then
              echo "API health check failed after 5 attempts! Response: $response"
              echo "Trying alternative path..."
              response=$(curl -s http://localhost:8000/api/v1/)
              if echo "$response" | grep -q '"status":"ok"'; then
                echo "API health check succeeded on alternative path!"
                break
              else
                echo "API health check failed on both paths! Response: $response"
                echo "Full logs:"
                docker-compose logs
                exit 1
              fi
            fi
            
            echo "Waiting 5 seconds before next attempt..."
            sleep 5
          done
          
          # Проверяем доступность фронтенда
          echo "Checking Frontend health..."
          response_code=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3000)
          if [[ "$response_code" = "200" ]]; then
            echo "Frontend health check succeeded!"
          else
            echo "Frontend health check failed! Response code: $response_code"
            echo "Trying to see if Nginx is running properly in the container..."
            docker exec $(docker ps | grep frontend | awk '{print $1}') nginx -t || echo "Nginx configuration test failed"
            docker exec $(docker ps | grep frontend | awk '{print $1}') ps aux || echo "Could not check processes in frontend container"
            docker-compose logs frontend
            exit 1
          fi
          
          echo "Deployment successful!" 